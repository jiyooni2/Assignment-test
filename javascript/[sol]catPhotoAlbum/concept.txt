모든 컴포넌트에서 setState, render 함수를 정의해야함, state에 따라 컴포넌트가 rendering 되야하므로

const a = new A(); => 호출과 동시에 객체 생성

this.render=()=>{} => 호출하는게 아님, 내부적으로 메소드 정의


    e.target.closet : 현재 클릭한 요소와 제일 인접한 요소 get



    element.innerHTML
    element.className
    document.createElement()

    display:none => 보이지 않음, 공간 차지하지도, 박스가 생성되지도 않음

개별 element의 css 수정
    element.style.display = 'block':'none'

각 모듈의 역할을 잘 생각하고, 각 모듈이 독립적으로 운영될수 있도록 하기

캐싱같은 경우, 모든 데이터를 중앙제어하고 있는, 모든 데이터가 모여있는 App에서 하는게 제일 효율적
캐싱의 대상은 당연히 nodes, 불러오는 데이터에 대한 캐싱

화면을 직접 렌더링하는 게 아니라, 어떠한 상태값을 정의하고, 상태가 변경이 될 때마다 UI가 업데이트
애플리케이션의 상태를 추상화하며, 상태를 기반으로 렌더링


assets의 src는 index.html의 위치 기준이다!!!
